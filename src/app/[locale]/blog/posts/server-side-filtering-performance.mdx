---
title: "Server-side Filtering, Pagination & Sorting: T·ªëi ∆∞u hi·ªáu nƒÉng API"
subtitle: "Performance best practices cho large datasets v·ªõi Entity Framework Core"
summary: "H∆∞·ªõng d·∫´n implement server-side filtering, pagination v√† sorting hi·ªáu qu·∫£ v·ªõi EF Core. Bao g·ªìm dynamic queries, Expression Trees, v√† performance benchmarks t·ª´ d·ª± √°n th·ª±c t·∫ø."
image: "/images/gallery/vertical-2.jpg"
publishedAt: "2025-01-08"
tag: "Performance"
---

## T·∫°i sao Server-side?

**Client-side approach** (‚ùå Bad):
```typescript
// Fetch ALL products (10,000 records)
const products = await fetch('/api/products/all');
// Filter in browser
const filtered = products.filter(p => p.category === 'Wine');
// Paginate in browser
const page = filtered.slice(0, 10);
```

**Problems**:
- üî¥ Network: Transfer megabytes of data
- üî¥ Memory: Browser dies v·ªõi large datasets
- üî¥ Performance: Slow, unresponsive UI
- üî¥ Security: Expose all data to client

**Server-side approach** (‚úÖ Good):
```typescript
// Fetch ONLY what's needed (10 records)
const products = await fetch('/api/products?category=Wine&page=1&size=10');
```

**Benefits**:
- ‚úÖ Network: Minimal data transfer
- ‚úÖ Memory: Efficient client-side
- ‚úÖ Performance: Lightning fast
- ‚úÖ Security: No excessive data exposure

## IQueryable vs IEnumerable

**Critical difference**:

```csharp
// ‚ùå BAD - IEnumerable (loads ALL data into memory)
public async Task<List<Product>> GetProducts()
{
    IEnumerable<Product> products = _context.Products; // All loaded
    var filtered = products.Where(p => p.Price > 100); // In-memory
    return filtered.ToList();
}

// ‚úÖ GOOD - IQueryable (SQL WHERE clause)
public async Task<List<Product>> GetProducts()
{
    IQueryable<Product> query = _context.Products; // Not executed
    query = query.Where(p => p.Price > 100); // Still not executed
    return await query.ToListAsync(); // NOW executed as SQL WHERE
}
```

**SQL Generated**:
```sql
-- IEnumerable: SELECT * FROM Products
-- Then filter 100,000 rows in C#

-- IQueryable: SELECT * FROM Products WHERE Price > 100
-- Database filters, returns 50 rows
```

## Pagination Implementation

### Basic Pagination Model

```csharp
namespace Application.Common.Models
{
    public class PaginatedList<T>
    {
        public List<T> Items { get; }
        public int PageNumber { get; }
        public int TotalPages { get; }
        public int TotalCount { get; }
        public int PageSize { get; }

        public PaginatedList(List<T> items, int count, int pageNumber, int pageSize)
        {
            Items = items;
            TotalCount = count;
            PageNumber = pageNumber;
            PageSize = pageSize;
            TotalPages = (int)Math.Ceiling(count / (double)pageSize);
        }

        public bool HasPreviousPage => PageNumber > 1;
        public bool HasNextPage => PageNumber < TotalPages;

        public static async Task<PaginatedList<T>> CreateAsync(
            IQueryable<T> source, 
            int pageNumber, 
            int pageSize)
        {
            var count = await source.CountAsync();
            var items = await source
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return new PaginatedList<T>(items, count, pageNumber, pageSize);
        }
    }
}
```

### Query Parameters

```csharp
namespace Application.Products.Queries.GetProducts
{
    public class GetProductsQuery : IRequest<PaginatedList<ProductDto>>
    {
        // Pagination
        public int PageNumber { get; set; } = 1;
        public int PageSize { get; set; } = 10;
        
        // Filtering
        public string SearchTerm { get; set; }
        public int? CategoryId { get; set; }
        public decimal? MinPrice { get; set; }
        public decimal? MaxPrice { get; set; }
        public bool? InStock { get; set; }
        
        // Sorting
        public string SortBy { get; set; } = "Name";
        public bool SortDescending { get; set; } = false;
    }
}
```

## Dynamic Filtering

### Approach 1: Manual Conditionals

```csharp
public class GetProductsQueryHandler 
    : IRequestHandler<GetProductsQuery, PaginatedList<ProductDto>>
{
    private readonly IApplicationDbContext _context;

    public async Task<PaginatedList<ProductDto>> Handle(
        GetProductsQuery request, 
        CancellationToken cancellationToken)
    {
        IQueryable<Product> query = _context.Products.AsNoTracking();

        // Apply filters
        if (!string.IsNullOrWhiteSpace(request.SearchTerm))
        {
            query = query.Where(p => 
                p.Name.Contains(request.SearchTerm) || 
                p.Description.Contains(request.SearchTerm));
        }

        if (request.CategoryId.HasValue)
        {
            query = query.Where(p => p.CategoryId == request.CategoryId.Value);
        }

        if (request.MinPrice.HasValue)
        {
            query = query.Where(p => p.Price >= request.MinPrice.Value);
        }

        if (request.MaxPrice.HasValue)
        {
            query = query.Where(p => p.Price <= request.MaxPrice.Value);
        }

        if (request.InStock.HasValue)
        {
            query = query.Where(p => p.Stock > 0);
        }

        // Apply sorting
        query = ApplySorting(query, request.SortBy, request.SortDescending);

        // Project to DTO and paginate
        var products = await query
            .Select(p => new ProductDto
            {
                Id = p.Id,
                Name = p.Name,
                Price = p.Price,
                CategoryName = p.Category.Name,
                InStock = p.Stock > 0
            })
            .PaginatedListAsync(request.PageNumber, request.PageSize, cancellationToken);

        return products;
    }
}
```

### Approach 2: Expression Trees (Advanced)

```csharp
using System.Linq.Expressions;

namespace Application.Common.Extensions
{
    public static class QueryableExtensions
    {
        public static IQueryable<T> ApplyFilter<T>(
            this IQueryable<T> query,
            string propertyName,
            object value,
            FilterOperator op = FilterOperator.Equal)
        {
            if (value == null) return query;

            var parameter = Expression.Parameter(typeof(T), "x");
            var property = Expression.Property(parameter, propertyName);
            var constant = Expression.Constant(value);

            Expression comparison = op switch
            {
                FilterOperator.Equal => Expression.Equal(property, constant),
                FilterOperator.GreaterThan => Expression.GreaterThan(property, constant),
                FilterOperator.LessThan => Expression.LessThan(property, constant),
                FilterOperator.Contains => Expression.Call(
                    property,
                    typeof(string).GetMethod("Contains", new[] { typeof(string) }),
                    constant
                ),
                _ => throw new NotImplementedException()
            };

            var lambda = Expression.Lambda<Func<T, bool>>(comparison, parameter);
            return query.Where(lambda);
        }
    }

    public enum FilterOperator
    {
        Equal,
        GreaterThan,
        LessThan,
        Contains
    }
}
```

**Usage**:
```csharp
query = query.ApplyFilter("Price", request.MinPrice, FilterOperator.GreaterThan);
query = query.ApplyFilter("Name", request.SearchTerm, FilterOperator.Contains);
```

## Dynamic Sorting

```csharp
namespace Application.Common.Extensions
{
    public static class QueryableExtensions
    {
        public static IQueryable<T> ApplySorting<T>(
            this IQueryable<T> query,
            string sortBy,
            bool descending = false)
        {
            if (string.IsNullOrWhiteSpace(sortBy))
                return query;

            var parameter = Expression.Parameter(typeof(T), "x");
            var property = Expression.Property(parameter, sortBy);
            var lambda = Expression.Lambda(property, parameter);

            var methodName = descending ? "OrderByDescending" : "OrderBy";
            var resultExpression = Expression.Call(
                typeof(Queryable),
                methodName,
                new Type[] { typeof(T), property.Type },
                query.Expression,
                Expression.Quote(lambda)
            );

            return query.Provider.CreateQuery<T>(resultExpression);
        }

        public static IQueryable<T> ApplyThenBy<T>(
            this IQueryable<T> query,
            string sortBy,
            bool descending = false)
        {
            var methodName = descending ? "ThenByDescending" : "ThenBy";
            // Similar to ApplySorting
            // ...
        }
    }
}
```

**Usage**:
```csharp
query = query
    .ApplySorting(request.SortBy, request.SortDescending)
    .ApplyThenBy("Id", false); // Secondary sort
```

## Performance Optimization

### 1. AsNoTracking for Read-Only Queries

```csharp
// ‚ùå BAD - Change tracking enabled (slower)
var products = await _context.Products.ToListAsync();

// ‚úÖ GOOD - No tracking for read-only
var products = await _context.Products
    .AsNoTracking()
    .ToListAsync();
```

**Performance impact**: 30-40% faster for large datasets!

### 2. Select Only What You Need (Projection)

```csharp
// ‚ùå BAD - Load entire entity with all relationships
var products = await _context.Products
    .Include(p => p.Category)
    .Include(p => p.Brand)
    .Include(p => p.Reviews)
    .ToListAsync();

// ‚úÖ GOOD - Project to DTO
var products = await _context.Products
    .Select(p => new ProductDto
    {
        Id = p.Id,
        Name = p.Name,
        Price = p.Price,
        CategoryName = p.Category.Name
    })
    .ToListAsync();
```

**Generated SQL**:
```sql
-- Bad: SELECT p.*, c.*, b.*, r.* FROM ...
-- Good: SELECT p.Id, p.Name, p.Price, c.Name FROM ...
```

### 3. Avoid N+1 Query Problem

```csharp
// ‚ùå BAD - N+1 queries
var products = await _context.Products.ToListAsync();
foreach (var product in products)
{
    var category = await _context.Categories
        .FindAsync(product.CategoryId); // 1 query per product!
}

// ‚úÖ GOOD - Include in one query
var products = await _context.Products
    .Include(p => p.Category)
    .ToListAsync();

// ‚úÖ EVEN BETTER - Projection
var products = await _context.Products
    .Select(p => new ProductDto
    {
        Id = p.Id,
        Name = p.Name,
        CategoryName = p.Category.Name
    })
    .ToListAsync();
```

### 4. Compiled Queries for Repeated Operations

```csharp
private static readonly Func<ApplicationDbContext, int, Task<Product>> 
    _getProductById = EF.CompileAsyncQuery(
        (ApplicationDbContext context, int id) =>
            context.Products.FirstOrDefault(p => p.Id == id)
    );

public async Task<Product> GetProductById(int id)
{
    return await _getProductById(_context, id);
}
```

### 5. Pagination Performance

```csharp
// ‚ùå SLOW for large offsets
var products = await _context.Products
    .OrderBy(p => p.Id)
    .Skip(10000)  // Scan 10,000 rows
    .Take(10)
    .ToListAsync();

// ‚úÖ BETTER - Keyset pagination
var products = await _context.Products
    .Where(p => p.Id > lastSeenId)
    .OrderBy(p => p.Id)
    .Take(10)
    .ToListAsync();
```

## Index Optimization

**Create indexes for filtered/sorted columns**:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Product>()
        .HasIndex(p => p.CategoryId);

    modelBuilder.Entity<Product>()
        .HasIndex(p => p.Price);

    modelBuilder.Entity<Product>()
        .HasIndex(p => new { p.CategoryId, p.Price });
}
```

## API Controller

```csharp
[HttpGet]
public async Task<ActionResult<PaginatedList<ProductDto>>> GetProducts(
    [FromQuery] GetProductsQuery query)
{
    var products = await _mediator.Send(query);

    // Add pagination metadata to headers
    Response.Headers.Add("X-Total-Count", products.TotalCount.ToString());
    Response.Headers.Add("X-Total-Pages", products.TotalPages.ToString());
    Response.Headers.Add("X-Current-Page", products.PageNumber.ToString());
    Response.Headers.Add("X-Page-Size", products.PageSize.ToString());

    return Ok(products);
}
```

## Frontend Implementation (Next.js)

```typescript
'use client';

import { useState } from 'use';
import useSWR from 'swr';

interface ProductsParams {
  page: number;
  size: number;
  search?: string;
  categoryId?: number;
  sortBy?: string;
  sortDesc?: boolean;
}

export function ProductsList() {
  const [params, setParams] = useState<ProductsParams>({
    page: 1,
    size: 12,
    sortBy: 'name',
  });

  const { data, isLoading } = useSWR(
    ['/api/products', params],
    ([url, params]) => fetchProducts(url, params)
  );

  const handleFilterChange = (filters: Partial<ProductsParams>) => {
    setParams({ ...params, ...filters, page: 1 });
  };

  const handlePageChange = (page: number) => {
    setParams({ ...params, page });
  };

  return (
    <div>
      <Filters onChange={handleFilterChange} />
      <ProductsGrid products={data?.items} loading={isLoading} />
      <Pagination
        currentPage={params.page}
        totalPages={data?.totalPages}
        onPageChange={handlePageChange}
      />
    </div>
  );
}
```

## Performance Benchmarks

From real project (10,000 products):

| Approach | Load Time | Data Transfer |
|----------|-----------|---------------|
| Client-side filtering | 2.5s | 1.2 MB |
| Server-side (no optimization) | 800ms | 50 KB |
| Server-side (optimized) | **150ms** | **12 KB** |

**Optimizations applied**:
- AsNoTracking
- Projection (Select only needed fields)
- Proper indexing
- Compiled queries

## Best Practices

‚úÖ **DO**:
- Always use IQueryable for dynamic queries
- AsNoTracking for read-only operations
- Project to DTOs early
- Index filtered/sorted columns
- Use pagination for all list endpoints
- Add request limits (max page size)

‚ùå **DON'T**:
- Load all data then filter in memory
- Use IEnumerable when you need IQueryable
- Include unnecessary relationships
- Allow unlimited page sizes
- Skip pagination "for convenience"

## Common Pitfalls

### Pitfall 1: Breaking the IQueryable chain
```csharp
// ‚ùå Breaks IQueryable
var products = query.ToList(); // All in memory now
products = products.Where(p => p.Price > 100).ToList();

// ‚úÖ Keep IQueryable
query = query.Where(p => p.Price > 100);
var products = await query.ToListAsync(); // Single SQL query
```

### Pitfall 2: Client evaluation
```csharp
// ‚ùå EF Core can't translate to SQL
query = query.Where(p => CustomMethod(p.Name));

// ‚úÖ Keep it SQL-translatable
query = query.Where(p => p.Name.Contains("search"));
```

## K·∫øt lu·∫≠n

Server-side filtering, pagination, v√† sorting l√† **ÂøÖÈ†à** cho scalable applications:

- üöÄ **Performance**: Ch·ªâ transfer data c·∫ßn thi·∫øt
- üíæ **Memory**: Kh√¥ng overload client
- üîí **Security**: Ki·ªÉm so√°t data exposure
- üìà **Scalability**: Handle millions of records

ƒê·∫ßu t∆∞ v√†o optimization n√†y ngay t·ª´ ƒë·∫ßu s·∫Ω ti·∫øt ki·ªám r·∫•t nhi·ªÅu th·ªùi gian refactor sau n√†y!
